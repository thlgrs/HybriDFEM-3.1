"""
Hybrid Column with GMSH-Generated FEM Meshes
=============================================
Demonstrates hybrid coupling between DFEM rigid blocks and FEM elements
with alternating horizontal slices (sandwich structure).

Scenario:
- Alternating slices of rigid DFEM blocks and unstructured FEM meshes
- FEM meshes generated by Gmsh (unstructured, non-matching nodes)
- Coupling: Mortar method (weak constraints for non-matching meshes)
- Cantilever loading: fixed base, horizontal + vertical load at top

Key Features:
- Gmsh for unstructured FEM mesh generation per slice
- Block-FEM mortar coupling using enable_block_fem_coupling()
- Saddle-point solver for exact constraint enforcement
- Supports Triangle3, Triangle6, Quad4, Quad8 elements
- Element size calculated relative to slice dimensions
"""

import os
import sys
from pathlib import Path

import numpy as np

# --- Path Setup ---
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

# --- Core Imports ---
from Core.Structures.Structure_Hybrid import Hybrid
from Core.Structures.Structure_FEM import Structure_FEM
from Core.Objects.DFEM.Block import Block_2D
from Core.Objects.ConstitutiveLaw.Material import Material, PlaneStress
from Core.Objects.FEM.Element2D import Geometry2D
from Core.Objects.FEM.Mesh import Mesh

# --- Utils Imports ---
from Examples.utils.mesh_generation import generate_block_slice
from Examples.utils.model_builders import setup_contact, find_nodes_at_height, find_nodes_at_length
from Examples.utils.visualization import visualize
from Examples.utils.solvers import run_solver
from Examples.utils.helpers import create_config

# =============================================================================
# CONFIGURATION
# =============================================================================
RESULTS_ROOT = str(project_root / 'Examples' / 'Results' / 'Hybrid' / 'hybrid_square_gmsh' / 'Stress')

BASE_CONFIG = {

    'geometry': {
        'width': 1.0,  # Column width (m)
        'thickness': .25,  # Out-of-plane thickness (m)
        'n_slices': 20,  # Number of alternating slices
        'start_with': 'block',  # First slice type at bottom
        'block_slice_height': 0.05,  # Height of block slices (m)
        'fem_slice_height': 0.05,  # Height of FEM slices (m)

        # Mesh Refinement
        'nx': 2,  # Blocks per row (horizontal)
        'ny_block_slice': 2,  # Block rows per slice (vertical)
        'ny_fem_slice': 2,  # Controls FEM element density
        'coupling_offset': 1e-6,  # Gap between slices for interface detection
    },
    'elements': {
        'type': 'quad',  # 'triangle' or 'quad'
        'order': 1,  # 1 (linear), 2 (quadratic)
        'quad9': False,
    },
    'material': {
        'block': {'E': 10e9, 'nu': 0.0, 'rho': 0},
        'fem': {'E': 10e9, 'nu': 0.0, 'rho': 0},
    },
    'contact': {
        'kn': 10e9, 'ks': 10e9, 'LG': True, 'nb_cps': 80
    },
    'coupling': {
        'method': 'mortar',  # ONLY mortar (GMSH meshes won't align)
        'tolerance': 0.001,  # Interface detection tolerance
        'integration_order': 2,  # Gauss quadrature order
        'interface_orientation': 'horizontal',  # All interfaces are horizontal
    },
    'bc': {
        'type': '',
    },
    'loads': {
        'Fx': 1e6,
        'Fy': -1e6,
    },
    'io': {
        'filename': 'hybrid_square',
        'dir': RESULTS_ROOT,
        'show_nodes': False,
        'figsize': (6, 6),
        'scale': 50
    }
}


# =============================================================================
# MESH GENERATION
# =============================================================================

def collect_fem_slice_surfaces(config):
    """
    Collect all FEM slice surface definitions for batch mesh generation.

    Parameters
    ----------
    config : dict
        Configuration dictionary

    Returns
    -------
    list of dict
        Surface definitions for Mesh.generate_batch(), each containing:
        - 'points': List of (x, y) boundary points (CCW order)
        - 'element_size': Target element size for this surface
        - 'name': Surface name for identification
    list of float
        Y-coordinate of each FEM slice bottom edge
    """
    g = config['geometry']
    n_slices = g['n_slices']
    start_with = g.get('start_with', 'block')
    width = g['width']
    offset = g.get('coupling_offset', 1e-6)

    # Helper to determine slice type
    def is_block_slice(idx):
        if start_with == 'block':
            return idx % 2 == 0
        else:
            return idx % 2 != 0

    surfaces = []
    y_coords = []
    current_y = 0.0
    fem_index = 0

    for i in range(n_slices):
        is_block = is_block_slice(i)

        if is_block:
            height = g['block_slice_height']
            current_y += height
        else:
            # FEM slice - collect surface definition
            height = g['fem_slice_height']
            ny = g.get('ny_fem_slice', 2)
            element_size = height / ny

            y_start = current_y
            y_end = current_y + height

            surfaces.append({
                'points': [
                    (0, y_start),  # Bottom-left
                    (width, y_start),  # Bottom-right
                    (width, y_end),  # Top-right
                    (0, y_end),  # Top-left
                ],
                'element_size': element_size,
                'name': f'fem_slice_{fem_index}'
            })
            y_coords.append(y_start)
            fem_index += 1
            current_y += height

        # Add offset between slices (except after last)
        if i < n_slices - 1:
            current_y += offset

    return surfaces, y_coords


def generate_fem_slice_mesh_gmsh(slice_index, y_start, height, config):
    """
    Generate GMSH mesh for a single FEM slice (fallback, kept for compatibility).

    Parameters
    ----------
    slice_index : int
        Index of this FEM slice (for unique mesh naming)
    y_start : float
        Y-coordinate of slice bottom edge
    height : float
        Height of the FEM slice
    config : dict
        Configuration dictionary

    Returns
    -------
    Mesh
        Generated mesh object with nodes and elements
    """
    g = config['geometry']
    e = config['elements']

    # Calculate element size from slice dimensions (matches structured grid density)
    ny = g.get('ny_fem_slice', 2)
    element_size = height / ny

    y_end = y_start + height

    # Define rectangular domain (CCW order)
    points = [
        (0, y_start),  # Bottom-left (interface with block below)
        (g['width'], y_start),  # Bottom-right
        (g['width'], y_end),  # Top-right
        (0, y_end),  # Top-left
    ]

    # Define edge groups for boundary identification
    edge_groups = {
        "bottom": [0],  # Interface with slice below
        "right": [1],
        "top": [2],  # Interface with slice above
        "left": [3],
    }

    mesh = Mesh(
        points=points,
        element_type=e['type'],
        element_size=element_size,
        order=e['order'],
        name=f"fem_slice_{slice_index}",
        edge_groups=edge_groups,
    )

    mesh.generate_mesh()
    return mesh


# =============================================================================
# MODEL GENERATION
# =============================================================================

def create_model(config, use_batch_generation=True):
    """
    Build complete hybrid structure with alternating block and GMSH-meshed FEM slices.

    Parameters
    ----------
    config : dict
        Configuration dictionary
    use_batch_generation : bool, default=True
        If True, uses Mesh.generate_batch() to generate all FEM meshes in a single
        GMSH operation. This is significantly faster than generating each mesh
        separately (eliminates repeated GMSH init/finalize and file I/O).
    """
    import time
    g = config['geometry']
    m = config['material']
    c = config['contact']
    cp = config['coupling']
    e = config['elements']

    print(f"\n" + "=" * 60)
    print(f"   BUILDING HYBRID COLUMN (GMSH): {g['n_slices']} Slices")
    print(f"   Start: {g.get('start_with', 'block')}, Method: {cp['method']}")
    print(f"   Element: {e['type']} order={e['order']}")
    print(f"   Batch Generation: {use_batch_generation}")
    print("=" * 60)

    St = Hybrid()
    mat_block = Material(**m['block'])
    mat_fem = PlaneStress(**m['fem'])
    geom = Geometry2D(t=g['thickness'])

    offset = g.get('coupling_offset', 1e-6)
    nx = g['nx']
    width = g['width']
    n_slices = g['n_slices']
    start_with = g.get('start_with', 'block')

    # Helper to determine slice type
    def is_block_slice(idx):
        if start_with == 'block':
            return idx % 2 == 0
        else:
            return idx % 2 != 0

    # ------------------------------------------------------------------
    # BATCH MESH GENERATION: Generate all FEM meshes at once
    # ------------------------------------------------------------------
    if use_batch_generation:
        print("\n  [Batch] Collecting FEM slice surfaces...")
        t0 = time.perf_counter()
        fem_surfaces, _ = collect_fem_slice_surfaces(config)

        if fem_surfaces:
            print(f"  [Batch] Generating {len(fem_surfaces)} meshes in single GMSH call...")
            fem_meshes = Mesh.generate_batch(
                surfaces=fem_surfaces,
                element_type=e['type'],
                order=e['order'],
                name_prefix='fem_slice'
            )
            mesh_time = time.perf_counter() - t0
            print(f"  [Batch] Generated {len(fem_meshes)} meshes in {mesh_time:.2f}s")
        else:
            fem_meshes = []
    else:
        fem_meshes = None  # Will generate per-slice

    # ------------------------------------------------------------------
    # BUILD STRUCTURE: Add blocks and FEM elements
    # ------------------------------------------------------------------
    current_y = 0.0
    fem_slice_counter = 0
    total_blocks = 0
    total_fem_elements = 0

    for i in range(n_slices):
        is_block = is_block_slice(i)

        if is_block:
            # --- Block Slice ---
            height = g['block_slice_height']
            ny = g.get('ny_block_slice', 2)

            # For mortar coupling, no interface alignment needed
            # Use default 'edge' strategy so boundary blocks have nodes at edges
            verts, refs = generate_block_slice(
                nx, ny, width, height,
                y_offset=current_y,
                interface_top=False,
                interface_bottom=False
                # ref_strategy='edge' is default
            )

            for v, r in zip(verts, refs):
                St.add_block(Block_2D(vertices=v, b=g['thickness'], material=mat_block, ref_point=r))
                total_blocks += 1

            current_y += height

        else:
            # --- FEM Slice (GMSH) ---
            height = g['fem_slice_height']

            if use_batch_generation and fem_meshes:
                # Use pre-generated mesh from batch
                mesh = fem_meshes[fem_slice_counter]
            else:
                # Generate mesh individually (fallback)
                mesh = generate_fem_slice_mesh_gmsh(fem_slice_counter, current_y, height, config)

            fem_slice_counter += 1

            # Create FEM elements from mesh
            St_fem = Structure_FEM.from_mesh(mesh, mat_fem, geom, prefer_quad9=e.get('quad9', False))
            for fe in St_fem.list_fes:
                St.add_fe(fe)
                total_fem_elements += 1

            current_y += height

        # Add offset between slices (except after last)
        if i < n_slices - 1:
            current_y += offset

    # Build node list
    St.make_nodes()

    print(f"\n  Structure Summary:")
    print(f"  -> Total blocks: {total_blocks}")
    print(f"  -> Total FEM elements: {total_fem_elements}")
    print(f"  -> Total nodes: {len(St.list_nodes)}")
    print(f"  -> Total DOFs: {St.nb_dofs}")
    print(f"  -> Total height: {current_y:.4f} m")

    # Setup block-block contact
    setup_contact(St, c['kn'], c['ks'], c['LG'], c.get('nb_cps', 20))

    # Enable mortar coupling
    print(f"\n  Enabling {cp['method'].upper()} coupling...")
    St.enable_block_fem_coupling(
        method='mortar',
        integration_order=cp['integration_order'],
        interface_tolerance=cp['tolerance'],
        interface_orientation=cp.get('interface_orientation', 'horizontal')
    )

    return St


# =============================================================================
# BOUNDARY CONDITIONS
# =============================================================================

def apply_conditions(St, config):
    g = config['geometry']
    l_conf = config['loads']
    bc_type = config['bc']['type']

    # Calculate total height
    n_slices = g['n_slices']
    start_block = (g['start_with'] == 'block')

    # Count types
    if start_block:
        n_block = (n_slices + 1) // 2
        n_fem = n_slices // 2
    else:
        n_fem = (n_slices + 1) // 2
        n_block = n_slices // 2

    total_height = (n_block * g['block_slice_height'] +
                    n_fem * g['fem_slice_height'] +
                    (n_slices - 1) * g.get('coupling_offset', 0))
    total_width = g['width']
    print(f"\nApplying Conditions (Type: {bc_type})")
    print(f"  Total Height ~ {total_height:.4f} m")

    # Find node sets
    tol = 1e-3
    bottom_set = set(find_nodes_at_height(St, 0.0, tolerance=tol))
    top_set = set(find_nodes_at_height(St, total_height, tolerance=tol))
    left_set = set(find_nodes_at_length(St, 0.0, tolerance=tol))
    right_set = set(find_nodes_at_length(St, total_width, tolerance=tol))
    center_x_set = set(find_nodes_at_length(St, total_width / 2, tolerance=0.1))

    if bc_type == 'shear':
        nodes_to_fix = list(bottom_set)
        for node in nodes_to_fix:
            St.fix_node(node_ids=[node], dofs=[0, 1, 2])
        nodes_to_load = list(top_set)
        control_node = list(top_set)[0]
        Fx = l_conf['Fx'] / len(nodes_to_load)
        St.load_node(node_ids=nodes_to_load, dofs=[0], force=Fx)

    elif bc_type == 'compression':
        # Fix base, compress from top
        nodes_to_fix = list(bottom_set)
        for node in nodes_to_fix:
            St.fix_node(node_ids=[node], dofs=[0, 1, 2])
        nodes_to_load = list(top_set.intersection(center_x_set))
        control_node = list(top_set.intersection(center_x_set))[0]
        Fy = l_conf['Fy'] / len(nodes_to_load)
        St.load_node(node_ids=nodes_to_load, dofs=[1], force=Fy)

    else:
        # Default: fix base
        nodes_to_fix = list(bottom_set)
        for node in nodes_to_fix:
            St.fix_node(node_ids=[node], dofs=[0, 1])
        control_node = list(top_set)[len(top_set) // 2]

    return St, control_node


# =============================================================================
# RESULTS ANALYSIS
# =============================================================================

def analyze_results(St, config, control_node):
    """Analyze results and save markdown report."""
    lines = []

    def log(text=""):
        print(text)
        lines.append(text)

    log("\n" + "=" * 60)
    log("   RESULTS ANALYSIS")
    log("=" * 60)

    # Displacements at control node
    dofs = St.get_dofs_from_node(control_node)
    ux = St.U[dofs[0]]
    uy = St.U[dofs[1]]

    log(f"\n**Control Node {control_node} (Top):**")
    log(f"  - ux={ux:.6e} m")
    log(f"  - uy={uy:.6e} m")

    # Constraint Residual (mortar verification)
    if hasattr(St, 'mortar_coupling') and St.mortar_coupling and St.mortar_coupling.constraint_matrix_C is not None:
        resid = np.linalg.norm(St.mortar_coupling.constraint_matrix_C @ St.U)
        log(f"\n**Mortar Constraint Residual:** {resid:.2e}")
        if resid < 1e-8:
            log("  [PASS] Constraints satisfied to machine precision")
        else:
            log("  [WARN] Residual above machine precision")

    # Save report
    io_conf = config['io']
    os.makedirs(io_conf['dir'], exist_ok=True)
    md_path = os.path.join(io_conf['dir'], io_conf['filename'] + ".md")
    with open(md_path, 'w', encoding='utf-8') as f:
        f.write('\n'.join(lines))
    print(f"\n[OK] Report saved to: {md_path}")


# =============================================================================
# EXECUTION
# =============================================================================

def run_config(config):
    """Run a single configuration."""
    name = config['io']['filename']
    print(f"\n{'=' * 60}")
    print(f"   Running: {name}")
    print(f"{'=' * 60}")

    St = create_model(config)
    St, c_node = apply_conditions(St, config)
    St = run_solver(St, config)
    analyze_results(St, config, c_node)
    visualize(St, config)

    print(f"\n[OK] Completed: {name}")
    return St


def run_configs(configs):
    """Run multiple configurations."""
    print(f"\nRunning {len(configs)} configuration(s):")
    for config in configs:
        print(f"  - {config['io']['filename']}")
    print()

    for config in configs:
        run_config(config)

    print(f"\n[OK] Completed {len(configs)} analyses")


# =============================================================================
# CONFIGURATION VARIANTS
# =============================================================================

COMPR_T3 = create_config(BASE_CONFIG, 'compression_hybrid_square_gmsh', bc={'type': 'compression'},
                         elements={'type': 'triangle', 'order': 1})
COMPR_T6 = create_config(BASE_CONFIG, 'compression_hybrid_square_gmsh', bc={'type': 'compression'},
                         elements={'type': 'triangle', 'order': 2}, coupling={'integration_order': 3})
COMPR_Q4 = create_config(BASE_CONFIG, 'compression_hybrid_square_gmsh', bc={'type': 'compression'},
                         elements={'type': 'quad', 'order': 1})

COMPR_Q9 = create_config(BASE_CONFIG, 'compression_hybrid_square_gmsh', bc={'type': 'compression'},
                         elements={'type': 'quad', 'order': 2, 'quad9': True}, coupling={'integration_order': 3})

SHEAR_T3 = create_config(BASE_CONFIG, 'shear_hybrid_square_gmsh', bc={'type': 'shear'},
                         elements={'type': 'triangle', 'order': 1})
SHEAR_T6 = create_config(BASE_CONFIG, 'shear_hybrid_square_gmsh', bc={'type': 'shear'},
                         elements={'type': 'triangle', 'order': 2}, coupling={'integration_order': 3})
SHEAR_Q4 = create_config(BASE_CONFIG, 'shear_hybrid_square_gmsh', bc={'type': 'shear'},
                         elements={'type': 'quad', 'order': 1})
SHEAR_Q8 = create_config(BASE_CONFIG, 'shear_hybrid_square_gmsh', bc={'type': 'shear'},
                         elements={'type': 'quad', 'order': 2, 'quad9': False}, coupling={'integration_order': 3})
SHEAR_Q9 = create_config(BASE_CONFIG, 'shear_hybrid_square_gmsh', bc={'type': 'shear'},
                         elements={'type': 'quad', 'order': 2, 'quad9': True}, coupling={'integration_order': 3})

SHEAR = [SHEAR_T3, SHEAR_T6, SHEAR_Q4, SHEAR_Q9]
COMPR = [COMPR_T3, COMPR_T6, COMPR_Q4, COMPR_Q9]
# =============================================================================
# MAIN
# =============================================================================

if __name__ == "__main__":
    run_configs(COMPR)
    run_configs(SHEAR)
